{Пробрасываем прокси БД
VSP -> Local прокси для БД Postgres через socat (PS Решение очень медленное, пинг 900)

***VSP***
Устанавливаем службу прокси для БД
sudo apt install socat -y

Заворачиваем в службу следующую команду (sudo socat TCP-LISTEN:55433,fork TCP:10.66.66.2:5432)

sudo nano /etc/systemd/system/pg-proxy.service

[Unit]
Description=PostgreSQL Proxy via socat
After=network.target
Wants=network-online.target

[Service]
Type=simple
ExecStart=/usr/bin/socat TCP-LISTEN:55433,fork TCP:10.66.66.2:5432
Restart=always
RestartSec=5

[Install]
WantedBy=multi-user.target

Активируем сервис

sudo systemctl daemon-reload
sudo systemctl enable --now pg-proxy
sudo systemctl status pg-proxy

***Local***
БД map_db
Пользователь map

В postgresql.conf ставим 
listen_addresses = '*'

В pg_hba.conf добавляем 
host    all    all    89.110.95.46/32    md5

И перезапускаем
sudo systemctl restart postgresql

***Доп проверки***
Проверк доступонсть сервиса со стороны VSP
nc -zv 10.66.66.2 5432

Проверка со стороны Local
ss -tulnp | grep 5432


VSP -> Local прокси для БД Postgres через nginx (PS Также медленно, но похуй, оставлю его)

***VSP***
Установить nginx с поддержкой stream (через официальный PPA)
sudo apt update
sudo apt install curl gnupg2 ca-certificates lsb-release -y

# Добавляем официальный репозиторий nginx
echo "deb http://nginx.org/packages/ubuntu $(lsb_release -cs) nginx" | sudo tee /etc/apt/sources.list.d/nginx.list
curl -fsSL https://nginx.org/keys/nginx_signing.key | sudo gpg --dearmor -o /usr/share/keyrings/nginx-archive-keyring.gpg
sudo nano /etc/apt/sources.list.d/nginx.list - Заменяем содержимое на
deb [signed-by=/usr/share/keyrings/nginx-archive-keyring.gpg] http://nginx.org/packages/ubuntu noble nginx
deb-src [signed-by=/usr/share/keyrings/nginx-archive-keyring.gpg] http://nginx.org/packages/ubuntu noble nginx

sudo apt update
sudo apt install nginx -y
nginx -V 2>&1 | grep -o with-stream

sudo nano /etc/nginx/nginx.conf
stream {
    upstream pg_backend {
        server 10.66.66.2:5432;
    }

    server {
        listen 55433;
        proxy_pass pg_backend;

        #access_log /var/log/nginx/pg-stream-access.log;
        #error_log /var/log/nginx/pg-stream-error.log;
    }
}

sudo nginx -t
sudo systemctl restart nginx

***Local***
Также как и в первом методе
}

{Настраиваем постгис для постгре
sudo apt-get install postgresql-14-postgis
map_db=# CREATE EXTENSION postgis;
}

{Параметры моей БД
Имя БД map_db
Пользователь map c классическим паролем
}

{Пробрасываем прокси к сайту с SSL сертами

***Создаем конфиг сайта в nginx***
sudo nano /etc/nginx/sites-available/dafomin.ru.conf

server {
    listen 80;
    listen [::]:80;
    server_name dafomin.ru www.dafomin.ru;

    location / {
        # Здесь ничего не должно быть
    }
}

***Создаем символическую ссылку для sites-enabled*** (Узнать зачем)

sudo ln -s /etc/nginx/sites-available/dafomin.ru.conf /etc/nginx/sites-enabled/

***Проверяем конфиг на ошибки и перезагружаем***
sudo nginx -t && sudo systemctl reload nginx

***Запуск cerbot для nginx и проходим по пунктам***

sudo certbot --nginx

***Переделываем что cerbot записал в dafomin.ru.conf
sudo nano /etc/nginx/sites-available/dafomin.ru.conf

server {
    listen 80;
    listen [::]:80;
    server_name dafomin.ru www.dafomin.ru;

    # Redirect all HTTP traffic to HTTPS
    return 301 https://$server_name$request_uri;
}

server {
    listen 443 ssl http2;
    listen [::]:443 ssl http2;
    server_name dafomin.ru www.dafomin.ru;

    ssl_certificate /etc/letsencrypt/live/dafomin.ru/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/dafomin.ru/privkey.pem;
    include /etc/letsencrypt/options-ssl-nginx.conf;
    ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem;

    # Reverse proxy configuration
    location / {
        proxy_pass http://10.66.66.2:8080;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }

    # Logging
    access_log /var/log/nginx/dafomin.ru-access.log;
    error_log /var/log/nginx/dafomin.ru-error.log;
}

***Проверяем конфиг на ошибки и перезагружаем***
sudo nginx -t && sudo systemctl reload nginx

}

{Парсим файл от нейронки на мелкие проги

	{manage.py
#Это сердце взаимодействия с вашим Django-проектом через командную строку.
#Как это используется?
#Вы никогда не меняете этот файл вручную. Вместо этого вы запускаете его из терминала для выполнения различных задач, например:
#    python manage.py runserver — запускает локальный веб-сервер для разработки.
#    python manage.py makemigrations — создает миграции для вашей базы данных.
#    python manage.py migrate — применяет миграции к базе данных.
#    python manage.py createsuperuser — создает учетную запись администратора.
}

	{settings.py
***Надо бы сгенерить секретный ключ SECRET_KEY***
#В Bash
python
#В Python
from django.core.management.utils import get_random_secret_key
get_random_secret_key()
*************************************************************************

***DEBUG*** #True на проде убрать

***ALLOWED_HOSTS = []*** #При разработке пусто, на проде выставить домен dafomin.ru и www.dafomin.ru

INSTALLED_APPS = [ 
    'django.contrib.admin', # Включает встроенную административную панель Django, которая позволяет управлять данными в вашей базе данных через удобный веб-интерфейс.
    'django.contrib.auth', # Предоставляет фреймворк для аутентификации, включая модели пользователей, группы и систему прав доступа.
    'django.contrib.contenttypes', # Позволяет создавать и работать с отношениями между моделями в динамическом режиме.
    'django.contrib.sessions', # Включает систему сессий для хранения данных, специфичных для каждого пользователя.
    'django.contrib.messages', # Добавляет фреймворк для вывода временных сообщений и уведомлений пользователям.
    'django.contrib.staticfiles', # Обеспечивает управление статическими файлами проекта (CSS, JavaScript, изображения).
    'django.contrib.gis', # Активирует GeoDjango, мощный набор инструментов для работы с геопространственными данными.
    'map_app', # Ваше собственное приложение, которое содержит логику, модели и шаблоны для проекта с картой. Вы создали его с помощью команды python manage.py startapp map_app ***ГДЕ СОЗДАЛ, ХУЙ ЗНАЕТ***
]

MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware', # Добавляет защиту от уязвимостей, таких как перенаправление на HTTPS и другие меры безопасности.
    'django.contrib.sessions.middleware.SessionMiddleware', # Включает поддержку сессий, позволяя Django управлять данными для каждого пользователя.
    'django.middleware.common.CommonMiddleware', # Выполняет общие функции, например, обработку URL (добавление/удаление слэша).
    'django.middleware.csrf.CsrfViewMiddleware', # Защищает от атак подделки межсайтовых запросов (CSRF) с помощью специальных токенов.
    'django.contrib.auth.middleware.AuthenticationMiddleware', # Связывает запросы с авторизованными пользователями, делая `request.user` доступным.
    'django.contrib.messages.middleware.MessageMiddleware', # Позволяет отображать временные сообщения (например, "Вы вошли в систему") пользователю.
    'django.middleware.clickjacking.XFrameOptionsMiddleware', # Защищает от атак кликджекинга, предотвращая встраивание страниц в `<frame>` или `<iframe>`.
]

ROOT_URLCONF = 'map.urls' #Главный список урлов, по которым джанго будет работать

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates', # Указывает, какой движок шаблонов использовать.
        'DIRS': [os.path.join(BASE_DIR, 'templates')], # Указывает Django, где искать шаблоны на уровне всего проекта.
        'APP_DIRS': True, # Говорит Django искать папку 'templates' внутри каждого приложения в INSTALLED_APPS.
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug', # Добавляет переменные для отладки в контекст шаблона.
                'django.template.context_processors.request', # Делает объект запроса ('request') доступным в шаблоне.
                'django.contrib.auth.context_processors.auth', # Делает переменные, связанные с аутентификацией, доступными в шаблоне.
                'django.contrib.messages.context_processors.messages', # Делает сообщения фреймворка доступными в шаблоне.
            ],
        },
    },
]

WSGI_APPLICATION = 'map.wsgi.application'  #Эта строка определяет, где Django должен искать WSGI-приложение.  WSGI (Web Server Gateway Interface) — это стандартный интерфейс между веб-сервером (например, Nginx, Gunicorn) и Python-приложением. Он позволяет веб-серверу взаимодействовать с вашим проектом Django, обрабатывать запросы и отправлять ответы. 
#map.wsgi: Указывает на файл wsgi.py внутри папки map
#application: Указывает на саму переменную application, которая определена внутри этого файла и является точкой входа для WSGI.

DATABASES = {
    'default': {
        'ENGINE': 'django.contrib.gis.db.backends.postgis', # Указывает на использование движка PostGIS для работы с геопространственными данными.
        'NAME': 'db_name', # Имя вашей базы данных. Замените на фактическое имя.
        'USER': 'db_user', # Имя пользователя для подключения к базе данных. Замените на ваше имя пользователя.
        'PASSWORD': 'db_password', # Пароль пользователя базы данных. Замените на ваш пароль.
        'HOST': 'localhost', # Хост, на котором работает база данных. Обычно localhost в разработке.
        'PORT': '5432', # Порт базы данных. Стандартный порт для PostgreSQL.
    }
}

#Валидатор паролей, в целом ок, но хз, надо ли мне.
AUTH_PASSWORD_VALIDATORS = [
    {
        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
    },
]

#Internationalization
#Устанавливает язык общения с программой и настраивает время так, чтобы было комфортно и программе и локальному пользователю

LANGUAGE_CODE = 'ru-ru'
TIME_ZONE = 'UTC'
USE_I18N = True
USE_TZ = True

#Хранение статических файлов (CSS, JavaScript, Images)
STATIC_URL = 'static/'
STATICFILES_DIRS = [
    os.path.join(BASE_DIR, 'static'),
]

#Параметры первичного ключа

DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'

}

	{urls.py
#Этот код — файл конфигурации URL-адресов urls.py для вашего Django-проекта. Он связывает URL-адреса, которые пользователь вводит в браузере, с соответствующими функциями, которые их обрабатывают.
from django.contrib import admin
from django.urls import path, include
from map_app.views import map_page, map_api

urlpatterns = [
    path('admin/', admin.site.urls), # Маршрут для встроенной административной панели Django.
    path('', map_page, name='map_page'),  # Главная страница, которая отображает карту.
    path('api/map_objects/', map_api, name='map_api'), # API-маршрут для обмена данными об объектах на карте.
]
}

	{models.py
from django.contrib.gis.db import models # Импортируем модели GeoDjango, которые поддерживают географические типы данных.

class MapObject(models.Model):
    """
    Модель для хранения геометрических объектов на карте.
    """
    name = models.CharField(max_length=255, blank=True, null=True, verbose_name="Название") # Поле для хранения названия объекта.
    description = models.TextField(blank=True, null=True, verbose_name="Описание") # Поле для хранения подробного описания.
    # Геометрическое поле. GeometryField может хранить любой тип геометрии.
    geometry = models.GeometryField(srid=4326, verbose_name="Геометрия") # Самое важное поле, хранит географические данные (точки, линии, полигоны). srid=4326 - стандарт WGS 84.
    photo_url = models.URLField(blank=True, null=True, verbose_name="URL фотографии") # Поле для хранения ссылки на фотографию.

    def __str__(self):
        return self.name if self.name else f'Объект #{self.pk}' # Возвращает строковое представление объекта, что удобно для админ-панели.

    class Meta:
        verbose_name = "Объект на карте" # Понятное имя модели в единственном числе.
        verbose_name_plural = "Объекты на карте" # Понятное имя модели во множественном числе.
}

	{views.py
import json # Импортируем модуль для работы с JSON-данными.
from django.shortcuts import render # Импортируем функцию для рендеринга HTML-шаблонов.
from django.http import JsonResponse # Импортируем класс для создания JSON-ответов.
from django.core.serializers import serialize # Импортируем функцию для преобразования объектов Django в другие форматы (например, GeoJSON).
from django.contrib.gis.geos import GEOSGeometry # Импортируем класс для создания геометрических объектов.

from .models import MapObject # Импортируем нашу модель для работы с объектами на карте.

def map_page(request):
    """
    Отображает главную страницу с картой.
    """
    return render(request, 'map.html') # Возвращает HTML-страницу, которая содержит карту.

def map_api(request):
    """
    API для работы с объектами на карте.
    - GET: возвращает все объекты в формате GeoJSON.
    - POST: сохраняет новый объект.
    """
    if request.method == 'GET':
        # Сериализуем все объекты из базы данных в формат GeoJSON
        queryset = MapObject.objects.all() # Получаем все объекты из базы данных.
        # use_natural_primary_keys=True
        geojson_data = serialize('geojson', queryset, geometry_field='geometry', fields=('name', 'description', 'photo_url')) # Преобразуем объекты в GeoJSON.
        return JsonResponse(json.loads(geojson_data), safe=False) # Отправляем GeoJSON в виде JSON-ответа.

    elif request.method == 'POST':
        try:
            # Загружаем JSON-тело запроса
            data = json.loads(request.body.decode('utf-8')) # Извлекаем JSON-данные из запроса.
            
            # Извлекаем тип и координаты геометрии
            geom_type = data['geometry']['type'] # Получаем тип геометрии (например, "Point", "Polygon").
            coords = data['geometry']['coordinates'] # Получаем координаты геометрии.

            # Создаем объект GEOSGeometry
            # GeoJSON формат.
            geom = GEOSGeometry(json.dumps({'type': geom_type, 'coordinates': coords})) # Создаем объект геометрии для сохранения в базе данных.
            
            # Извлекаем свойства объекта
            properties = data.get('properties', {}) # Извлекаем свойства объекта (название, описание и т.д.).
            name = properties.get('name', 'Новый объект')
            description = properties.get('description', '')
            photo_url = properties.get('photo_url', '')

            # Создаем и сохраняем новый объект в базе данных
            new_object = MapObject.objects.create( # Создаем новую запись в базе данных.
                name=name,
                description=description,
                geometry=geom,
                photo_url=photo_url
            )
            
            # Сериализуем созданный объект и возвращаем ответ
            geojson_object = serialize('geojson', [new_object], geometry_field='geometry', fields=('name', 'description', 'photo_url')) # Преобразуем новый объект в GeoJSON для ответа.
            return JsonResponse(json.loads(geojson_object), status=201) # Возвращаем данные нового объекта с кодом 201 (Created).

        except (json.JSONDecodeError, KeyError) as e:
            return JsonResponse({'error': f'Неверный формат данных: {e}'}, status=400) # Обрабатываем ошибки, если данные неверны.
    
    return JsonResponse({'error': 'Метод не поддерживается'}, status=405) # Возвращаем ошибку, если был использован неподдерживаемый HTTP-метод.

} #Удалить эту скобку
}

	{map.html
#Этот код представляет собой стандартный HTML-шаблон для вашей веб-страницы с интерактивной картой. 🌐 Он отвечает за структуру и подключение всех необходимых ресурсов для отображения карты и инструментов рисования.
	}

	{main.js
#Этот код — это клиентская часть вашего проекта, написанная на JavaScript. Он отвечает за всю интерактивную логику на стороне браузера — от отображения карты до взаимодействия с Django API.
}

}